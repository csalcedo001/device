#!/usr/bin/env python3

import click
import json
import os
import pathlib

root_path = os.path.join(str(pathlib.Path.home()), ".dv")
devices_json_path = os.path.join(root_path, "devices.json")


### Loading data

def load_devices():
    with open(devices_json_path) as input_json:
        devices = json.load(input_json)

    return devices

def save_devices(devices):
    with open(devices_json_path, "w") as output_json:
        json.dump(devices, output_json)



def get_devices_match(ctx, args, incomplete):
    return [k for k in load_devices().keys() if incomplete in k]



# ### Useful functions

def command_quote_nest(command, quote='"'):
    bs = '\\'   # Backslash
    command = command.replace(bs, bs + bs)
    command = command.replace(quote, bs + quote)
    command = quote + command + quote
    return command

# def val_device(devices, name):
#     if name not in devices:
#         click.echo("No device named '{}' found.".format(name))
#         exit()



### Main CLI

@click.group()
def cli():
    pass



### Device list manipulation commands
    
@click.group()
def add():
    pass

@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
@click.argument("ip", nargs=-1)
def ssh(name, ip):
    devices = load_devices()
    
    if name in devices:
        click.echo("Device named '{}' already exists.".format(name))
        return

    ips = list(ip)

    device_description = {
        "type": "ssh",
        "ips": ips
    }

    devices[name] = device_description

    save_devices(devices)

@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
@click.option("--container", help="Container name")
def docker(name, container):
    devices = load_devices()
    
    if name in devices:
        click.echo("Device named '{}' already exists.".format(name))
        return

    if container == None:
        container = name

    device_description = {
        "type": "docker",
        "container": container
    }

    devices[name] = device_description

    save_devices(devices)


@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
def rm(name):
    devices = load_devices()

    if name not in devices:
        click.echo("error: No device named '{}' found.".format(name))
        return

    if click.confirm("Are you sure you want to remove device '{}'?".format(name), default=None):
        click.echo("Removed device '{}'".format(name))

        del devices[name]

    save_devices(devices)




### Device list observation commands
@click.command()
def ls():
    devices = load_devices()

    click.echo("List of available devices:")
    for name in devices:
        click.echo("* {}: type={}".format(name, devices[name]["type"]))
    
    click.echo()




### Device list observation commands
@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
@click.argument("attribute")
def info(name, attribute):
    devices = load_devices()

    if name not in devices:
        click.echo("error: No device named '{}' found.".format(name))
        return
    
    if attribute != 'attributes' and attribute not in devices[name]:
        click.echo("error: No attribute '{}' for device '{}' of type '{}'.".format(attribute, name, devices[name]['type']))
        return
    
    if attribute == 'attributes':
        value = list(devices[name].keys())
    else:
        value = devices[name][attribute]
        
    if type(value) == list:
        value = '\n'.join(value)

    click.echo(value)



# Connection commands
@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
@click.option("-f", "--force-connection", is_flag=True, default=False)
def connect(name, force_connection):
    devices = load_devices()

    names = name.split(':')
    types = []
    for name in names:
        if name in devices:
            types.append(devices[name]["type"])
        else:
            if not force_connection:
                click.echo("No device named '{}' found. If this is a URL and want to reference it, run with the flag -f.".format(name))
                return
            else:
                types.append("ip")    # In this case, name isn't a name but an IP

    if ("ssh" in types or "ip" in types) and "docker" in types:
        click.echo("Connection through an IP and docker container simultaneously is not supported.")
        return
    
    if "docker" in types and len(types) > 1:
        click.echo("Connection through 2 or more docker containers is not supported.")
        return
    

    if "ssh" in types or "ip" in types:
        ips = []
        refs = []
        for i, name in enumerate(names):
            if types[i] == "ssh":
                ips += devices[name]["ips"]
                refs += devices[name]["ips"][:-1]
                refs.append(name)
            else:
                ips.append(name)
                refs.append(name)

        command = "ssh " + " -t ssh ".join(ips)

        # Reverse lists
        ips = ips[::-1]
        refs = refs[::-1]

        command = "echo 'Connecting to {}...'; ssh ".format(refs[0]) + ips[0]

        for i in range(1, len(ips)):
               command = "echo 'Connecting to {}...'; ssh ".format(refs[i]) + ips[i] + " -t " + command_quote_nest(command, quote='"')

    elif "docker" in types:
        command = "docker_connect.sh {}".format(devices[names[0]]["container"])
    
    
    os.system(command)
    


@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
@click.argument("port")
def tunnel(name, port):
    devices = load_devices()

    if name not in devices:
        click.echo("No device named '{}' found.".format(name))
        return

    device_type = devices[name]["type"]

    if device_type == "ssh":
        ssh_command = "ssh -L {0}:localhost:{0} ".format(port)
        command = ssh_command + (" -t " + ssh_command).join(devices[name]["ips"])

    click.echo("Tunneling to '{}' through port '{}'...".format(name, port))
    os.system(command)


@click.command()
@click.argument("source")
@click.argument("dest")
@click.option("-r", "--recursive", is_flag=True, default=False)
def cp(source, dest, recursive):
    source_parts = source.split(":")
    if len(source_parts) > 2:
        click.echo("error: Invalid source {}.".format(source))
        return

    dest_parts = dest.split(":")
    if len(dest_parts) > 2:
        click.echo("error: Invalid destination {}.".format(dest))
        return

    
    devices = load_devices()
    
    flags = ""
    if recursive:
        flags += "-r "
    
    if len(source_parts) == 1 or not source_parts[0] in devices:
        source_path = source
    else:
        device = devices[source_parts[0]]

        if device["type"] == "docker":
            click.echo("error: copy command for device of type 'docker' is not supported.")
            return

        source_path = device["ips"][-1] + ":" + source_parts[1]
        if len(device["ips"]) == 1:
            pass
        elif len(device["ips"]) == 2:
            proxy_command = "-oProxyCommand=\"ssh -W %h:%p "
            proxy_command += device["ips"][0]
            proxy_command += "\" "
            
            flags += proxy_command
        else:
            click.echo("error: copy command for more than 2 IPs is not supported.")
            return

    
    if len(dest_parts) == 1 or not dest_parts[0] in devices:
        dest_path = dest
    else:
        device = devices[dest_parts[0]]

        if device["type"] == "docker":
            click.echo("error: copy command for device of type 'docker' is not supported.")
            return

        dest_path = device["ips"][-1] + ":" + dest_parts[1]
        if len(device["ips"]) == 1:
            pass
        elif len(device["ips"]) == 2:
            proxy_command = "-oProxyCommand=\"ssh -W %h:%p "
            proxy_command += device["ips"][0]
            proxy_command += "\" "
            
            flags += proxy_command
        else:
            click.echo("error: copy command for more than 2 IPs is not supported.")
            return

    command = "scp {} {} {}".format(flags, source_path, dest_path)

    os.system(command)

@click.command()
@click.argument("old")
@click.argument("new")
def rename(old, new):
    devices = load_devices()

    if old not in devices:
        click.echo("No device named '{}' found.".format(old))
        return

    if new in devices and new != old:
        click.echo("Device named '{}' already exists.".format(new))
        return
    
    if new != old:
        devices[new] = devices[old]
        del devices[old]

        save_devices(devices)

@click.command()
@click.argument("name", type=click.STRING, autocompletion=get_devices_match)
@click.argument("cmd", type=click.STRING)
def run(name, cmd):
    devices = load_devices()

    if name not in devices:
        click.echo("No device named '{}' found.".format(name))
        return

    if '"' in cmd:
        click.echo("No support for commands that contain '\"'. Use \"'\" if possible.")
        return

    command = 'ssh -t '
    command += devices[name]["ips"][0] + ' '
    command += cmd

    os.system(command)
    


### Add all commands
add.add_command(ssh)
add.add_command(docker)

cli.add_command(add)
cli.add_command(rm)
cli.add_command(ls)
cli.add_command(info)
cli.add_command(connect)
cli.add_command(tunnel)
cli.add_command(cp)
cli.add_command(rename)
cli.add_command(run)


if __name__ == '__main__':
    if not os.path.exists(root_path):
        os.mkdir(root_path)
    if not os.path.exists(devices_json_path):
        save_devices({})
        
    cli()
